/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlertContactObservation struct {
}

type AlertContactParameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Recurrence *float64 `json:"recurrence,omitempty" tf:"recurrence,omitempty"`

	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`
}

type MonitorObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type MonitorParameters struct {

	// +kubebuilder:validation:Optional
	AlertContact []AlertContactParameters `json:"alertContact,omitempty" tf:"alert_contact,omitempty"`

	// +kubebuilder:validation:Optional
	CustomHTTPHeaders map[string]*string `json:"customHttpHeaders,omitempty" tf:"custom_http_headers,omitempty"`

	// +kubebuilder:validation:Required
	FriendlyName *string `json:"friendlyName" tf:"friendly_name,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPAuthType *string `json:"httpAuthType,omitempty" tf:"http_auth_type,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPPasswordSecretRef *v1.SecretKeySelector `json:"httpPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	HTTPUsername *string `json:"httpUsername,omitempty" tf:"http_username,omitempty"`

	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// +kubebuilder:validation:Optional
	KeywordType *string `json:"keywordType,omitempty" tf:"keyword_type,omitempty"`

	// +kubebuilder:validation:Optional
	KeywordValue *string `json:"keywordValue,omitempty" tf:"keyword_value,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	SubType *string `json:"subType,omitempty" tf:"sub_type,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`
}

// MonitorSpec defines the desired state of Monitor
type MonitorSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MonitorParameters `json:"forProvider"`
}

// MonitorStatus defines the observed state of Monitor.
type MonitorStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MonitorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Monitor is the Schema for the Monitors API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,uptimerobotjet}
type Monitor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitorSpec   `json:"spec"`
	Status            MonitorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MonitorList contains a list of Monitors
type MonitorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Monitor `json:"items"`
}

// Repository type metadata.
var (
	Monitor_Kind             = "Monitor"
	Monitor_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Monitor_Kind}.String()
	Monitor_KindAPIVersion   = Monitor_Kind + "." + CRDGroupVersion.String()
	Monitor_GroupVersionKind = CRDGroupVersion.WithKind(Monitor_Kind)
)

func init() {
	SchemeBuilder.Register(&Monitor{}, &MonitorList{})
}
